package org.ironlions.sovereign.smc

/**
 * A controller for a (possibly finite) state machine.
 */
class Controller(states: Array<State>) {
    private val graphvizDotPrelude = """digraph {
    comment="This file was generated by "${this.javaClass.canonicalName}"""

    /* The flat list of states. The key is the state, the value is if it's been reached. */
    private val statesReached = HashMap<State, Boolean>()

    /* Unique state registry. */
    private val uniqueStateRegistry = HashMap<StateRole, State>()

    /* The current state. */
    private var currentState: State

    /* Are we done? */
    private var terminated = false

    init {
        if (states.isEmpty()) throw ConstructionException("no states in state machine")

        for (state in states) {
            /* Make sure two identical states aren't supplied. */
            if (statesReached.containsKey(state)) {
                throw ConstructionException(
                    state.javaClass,
                    "state of ditto type '${state.javaClass.simpleName}' already included in state machine",
                )
            }

            /* Make sure we have the annotation needed, and load them. */
            val metadata: StateMeta =
                state.javaClass.getAnnotation(StateMeta::class.java) ?: throw ConstructionException(
                    state.javaClass,
                    "isn't annotated with StateMeta",
                )

            /* Ensure there's only one INITIAL and TERMINATING state. */
            if (metadata.role != StateRole.TRANSITIONAL) {
                /* Is there's already a matching one in the registry,
                 * kill ourselves. */
                uniqueStateRegistry.getOrPut(metadata.role) { state }.takeIf { it != state }?.let {
                    throw ConstructionException(
                        state.javaClass,
                        "another state marked as " + metadata.role + ", '" + uniqueStateRegistry[metadata.role]!!.javaClass.simpleName + "', is already included in state machine.",
                    )
                }
            }
        }

        currentState = uniqueStateRegistry[StateRole.INITIAL] ?: throw ConstructionException(
            "no INITIAL state was supplied",
        )
    }

    /**
     * Returns if the current state machine has a terminating state. If false, the state machine
     * will never terminate, but if it's true, there's a *chance* it will.
     *
     * @return If the state machine has a terminating state.
     */
    fun hasTerminatingState(): Boolean {
        return uniqueStateRegistry.containsKey(StateRole.FINAL)
    }

    /**
     * Called on every frame of the robot, it ticks and manages the state machine.
     */
    fun loop() {
        if (terminated) return

        /* Sanity. */
        assert(statesReached.isNotEmpty())

        /* Run init() once we reach the state. */
        statesReached[currentState]?.takeIf { !it }?.let {
            currentState.init()
            statesReached[currentState] = true
        }

        /* Run the current state's looping function. */
        currentState.loop()

        /* Active state state switching logic. */
        for (edge in currentState.edges) {
            if (!edge.callback(currentState)) continue

            /* TODO: Log non-determinism if .find() finds more than one match */
            val currentState =
                statesReached.keys.find { it.javaClass == edge.to }?.apply { start() }
                    ?: throw UnknownStateException(edge.to)

            /* It's fine to use '==' here, since we're checking for object identity, not
             * equivalence. Thanks AP CSA! */
            terminated = uniqueStateRegistry[StateRole.FINAL] === currentState

            break
        }
    }

    /**
     * Generate a Graphviz DOT diagram of the currently fixed state machine.
     * <br/>
     * TODO: Support and show diagnostics.
     */
    fun generateDot(): String {
        return buildString {
            append(graphvizDotPrelude)

            for (state in statesReached.keys) {
                /* Styling and whatnot of the vertices/nodes. */
                val metadata = state.javaClass.getAnnotation(StateMeta::class.java)!!
                append("\t\"${state.javaClass.simpleName}\" [color = \"${metadata.color}\"]\n")

                /* Edges between vertices/nodes. */
                for (edge in state.edges) {
                    append("\t\"${state.javaClass.simpleName}\" -> \"${edge.to.simpleName}\"\n")
                }
            }

            /* Cleanup. */
            append("}")
        }
    }
}

/**
 * A runtime exception representing an error that occurred during state machine construction, not
 * runtime.
 */
class ConstructionException(offender: Class<*>?, reason: String) : RuntimeException(
    when (offender) {
        null -> "State machine construction is invalid': $reason."
        else -> "State machine construction is invalid, caused by state '" + offender.simpleName + "': " + reason + "."
    },
) {
    constructor(reason: String) : this(null, reason)
}

/**
 * A runtime exception representing an unknown state.
 */
class UnknownStateException(offender: Class<*>) :
    RuntimeException("Valve function referenced unknown state, '" + offender.simpleName + "'.")